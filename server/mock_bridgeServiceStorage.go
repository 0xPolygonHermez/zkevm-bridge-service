// Code generated by mockery. DO NOT EDIT.

package server

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	etherman "github.com/0xPolygonHermez/zkevm-bridge-service/etherman"

	mock "github.com/stretchr/testify/mock"

	pgx "github.com/jackc/pgx/v4"
)

// bridgeServiceStorageMock is an autogenerated mock type for the bridgeServiceStorage type
type bridgeServiceStorageMock struct {
	mock.Mock
}

type bridgeServiceStorageMock_Expecter struct {
	mock *mock.Mock
}

func (_m *bridgeServiceStorageMock) EXPECT() *bridgeServiceStorageMock_Expecter {
	return &bridgeServiceStorageMock_Expecter{mock: &_m.Mock}
}

// Get provides a mock function with given fields: ctx, key, dbTx
func (_m *bridgeServiceStorageMock) Get(ctx context.Context, key []byte, dbTx pgx.Tx) ([][]byte, error) {
	ret := _m.Called(ctx, key, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 [][]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, pgx.Tx) ([][]byte, error)); ok {
		return rf(ctx, key, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte, pgx.Tx) [][]byte); ok {
		r0 = rf(ctx, key, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte, pgx.Tx) error); ok {
		r1 = rf(ctx, key, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type bridgeServiceStorageMock_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key []byte
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) Get(ctx interface{}, key interface{}, dbTx interface{}) *bridgeServiceStorageMock_Get_Call {
	return &bridgeServiceStorageMock_Get_Call{Call: _e.mock.On("Get", ctx, key, dbTx)}
}

func (_c *bridgeServiceStorageMock_Get_Call) Run(run func(ctx context.Context, key []byte, dbTx pgx.Tx)) *bridgeServiceStorageMock_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_Get_Call) Return(_a0 [][]byte, _a1 error) *bridgeServiceStorageMock_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_Get_Call) RunAndReturn(run func(context.Context, []byte, pgx.Tx) ([][]byte, error)) *bridgeServiceStorageMock_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetClaim provides a mock function with given fields: ctx, index, networkID, dbTx
func (_m *bridgeServiceStorageMock) GetClaim(ctx context.Context, index uint, networkID uint, dbTx pgx.Tx) (*etherman.Claim, error) {
	ret := _m.Called(ctx, index, networkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetClaim")
	}

	var r0 *etherman.Claim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, uint, pgx.Tx) (*etherman.Claim, error)); ok {
		return rf(ctx, index, networkID, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, uint, pgx.Tx) *etherman.Claim); ok {
		r0 = rf(ctx, index, networkID, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*etherman.Claim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, uint, pgx.Tx) error); ok {
		r1 = rf(ctx, index, networkID, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClaim'
type bridgeServiceStorageMock_GetClaim_Call struct {
	*mock.Call
}

// GetClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - index uint
//   - networkID uint
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetClaim(ctx interface{}, index interface{}, networkID interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetClaim_Call {
	return &bridgeServiceStorageMock_GetClaim_Call{Call: _e.mock.On("GetClaim", ctx, index, networkID, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetClaim_Call) Run(run func(ctx context.Context, index uint, networkID uint, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(uint), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetClaim_Call) Return(_a0 *etherman.Claim, _a1 error) *bridgeServiceStorageMock_GetClaim_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetClaim_Call) RunAndReturn(run func(context.Context, uint, uint, pgx.Tx) (*etherman.Claim, error)) *bridgeServiceStorageMock_GetClaim_Call {
	_c.Call.Return(run)
	return _c
}

// GetClaimCount provides a mock function with given fields: ctx, destAddr, dbTx
func (_m *bridgeServiceStorageMock) GetClaimCount(ctx context.Context, destAddr string, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, destAddr, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetClaimCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, destAddr, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, pgx.Tx) uint64); ok {
		r0 = rf(ctx, destAddr, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, pgx.Tx) error); ok {
		r1 = rf(ctx, destAddr, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetClaimCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClaimCount'
type bridgeServiceStorageMock_GetClaimCount_Call struct {
	*mock.Call
}

// GetClaimCount is a helper method to define mock.On call
//   - ctx context.Context
//   - destAddr string
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetClaimCount(ctx interface{}, destAddr interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetClaimCount_Call {
	return &bridgeServiceStorageMock_GetClaimCount_Call{Call: _e.mock.On("GetClaimCount", ctx, destAddr, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetClaimCount_Call) Run(run func(ctx context.Context, destAddr string, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetClaimCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetClaimCount_Call) Return(_a0 uint64, _a1 error) *bridgeServiceStorageMock_GetClaimCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetClaimCount_Call) RunAndReturn(run func(context.Context, string, pgx.Tx) (uint64, error)) *bridgeServiceStorageMock_GetClaimCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetClaims provides a mock function with given fields: ctx, destAddr, limit, offset, dbTx
func (_m *bridgeServiceStorageMock) GetClaims(ctx context.Context, destAddr string, limit uint, offset uint, dbTx pgx.Tx) ([]*etherman.Claim, error) {
	ret := _m.Called(ctx, destAddr, limit, offset, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetClaims")
	}

	var r0 []*etherman.Claim
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint, uint, pgx.Tx) ([]*etherman.Claim, error)); ok {
		return rf(ctx, destAddr, limit, offset, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint, uint, pgx.Tx) []*etherman.Claim); ok {
		r0 = rf(ctx, destAddr, limit, offset, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*etherman.Claim)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint, uint, pgx.Tx) error); ok {
		r1 = rf(ctx, destAddr, limit, offset, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetClaims_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClaims'
type bridgeServiceStorageMock_GetClaims_Call struct {
	*mock.Call
}

// GetClaims is a helper method to define mock.On call
//   - ctx context.Context
//   - destAddr string
//   - limit uint
//   - offset uint
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetClaims(ctx interface{}, destAddr interface{}, limit interface{}, offset interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetClaims_Call {
	return &bridgeServiceStorageMock_GetClaims_Call{Call: _e.mock.On("GetClaims", ctx, destAddr, limit, offset, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetClaims_Call) Run(run func(ctx context.Context, destAddr string, limit uint, offset uint, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetClaims_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint), args[3].(uint), args[4].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetClaims_Call) Return(_a0 []*etherman.Claim, _a1 error) *bridgeServiceStorageMock_GetClaims_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetClaims_Call) RunAndReturn(run func(context.Context, string, uint, uint, pgx.Tx) ([]*etherman.Claim, error)) *bridgeServiceStorageMock_GetClaims_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeposit provides a mock function with given fields: ctx, depositCnt, networkID, dbTx
func (_m *bridgeServiceStorageMock) GetDeposit(ctx context.Context, depositCnt uint, networkID uint, dbTx pgx.Tx) (*etherman.Deposit, error) {
	ret := _m.Called(ctx, depositCnt, networkID, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDeposit")
	}

	var r0 *etherman.Deposit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, uint, pgx.Tx) (*etherman.Deposit, error)); ok {
		return rf(ctx, depositCnt, networkID, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, uint, pgx.Tx) *etherman.Deposit); ok {
		r0 = rf(ctx, depositCnt, networkID, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*etherman.Deposit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, uint, pgx.Tx) error); ok {
		r1 = rf(ctx, depositCnt, networkID, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetDeposit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeposit'
type bridgeServiceStorageMock_GetDeposit_Call struct {
	*mock.Call
}

// GetDeposit is a helper method to define mock.On call
//   - ctx context.Context
//   - depositCnt uint
//   - networkID uint
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetDeposit(ctx interface{}, depositCnt interface{}, networkID interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetDeposit_Call {
	return &bridgeServiceStorageMock_GetDeposit_Call{Call: _e.mock.On("GetDeposit", ctx, depositCnt, networkID, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetDeposit_Call) Run(run func(ctx context.Context, depositCnt uint, networkID uint, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetDeposit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(uint), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetDeposit_Call) Return(_a0 *etherman.Deposit, _a1 error) *bridgeServiceStorageMock_GetDeposit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetDeposit_Call) RunAndReturn(run func(context.Context, uint, uint, pgx.Tx) (*etherman.Deposit, error)) *bridgeServiceStorageMock_GetDeposit_Call {
	_c.Call.Return(run)
	return _c
}

// GetDepositCount provides a mock function with given fields: ctx, destAddr, dbTx
func (_m *bridgeServiceStorageMock) GetDepositCount(ctx context.Context, destAddr string, dbTx pgx.Tx) (uint64, error) {
	ret := _m.Called(ctx, destAddr, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDepositCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, pgx.Tx) (uint64, error)); ok {
		return rf(ctx, destAddr, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, pgx.Tx) uint64); ok {
		r0 = rf(ctx, destAddr, dbTx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, pgx.Tx) error); ok {
		r1 = rf(ctx, destAddr, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetDepositCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDepositCount'
type bridgeServiceStorageMock_GetDepositCount_Call struct {
	*mock.Call
}

// GetDepositCount is a helper method to define mock.On call
//   - ctx context.Context
//   - destAddr string
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetDepositCount(ctx interface{}, destAddr interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetDepositCount_Call {
	return &bridgeServiceStorageMock_GetDepositCount_Call{Call: _e.mock.On("GetDepositCount", ctx, destAddr, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetDepositCount_Call) Run(run func(ctx context.Context, destAddr string, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetDepositCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetDepositCount_Call) Return(_a0 uint64, _a1 error) *bridgeServiceStorageMock_GetDepositCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetDepositCount_Call) RunAndReturn(run func(context.Context, string, pgx.Tx) (uint64, error)) *bridgeServiceStorageMock_GetDepositCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetDepositCountByRoot provides a mock function with given fields: ctx, root, network, dbTx
func (_m *bridgeServiceStorageMock) GetDepositCountByRoot(ctx context.Context, root []byte, network uint8, dbTx pgx.Tx) (uint, error) {
	ret := _m.Called(ctx, root, network, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDepositCountByRoot")
	}

	var r0 uint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, uint8, pgx.Tx) (uint, error)); ok {
		return rf(ctx, root, network, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte, uint8, pgx.Tx) uint); ok {
		r0 = rf(ctx, root, network, dbTx)
	} else {
		r0 = ret.Get(0).(uint)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte, uint8, pgx.Tx) error); ok {
		r1 = rf(ctx, root, network, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetDepositCountByRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDepositCountByRoot'
type bridgeServiceStorageMock_GetDepositCountByRoot_Call struct {
	*mock.Call
}

// GetDepositCountByRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - root []byte
//   - network uint8
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetDepositCountByRoot(ctx interface{}, root interface{}, network interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetDepositCountByRoot_Call {
	return &bridgeServiceStorageMock_GetDepositCountByRoot_Call{Call: _e.mock.On("GetDepositCountByRoot", ctx, root, network, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetDepositCountByRoot_Call) Run(run func(ctx context.Context, root []byte, network uint8, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetDepositCountByRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte), args[2].(uint8), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetDepositCountByRoot_Call) Return(_a0 uint, _a1 error) *bridgeServiceStorageMock_GetDepositCountByRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetDepositCountByRoot_Call) RunAndReturn(run func(context.Context, []byte, uint8, pgx.Tx) (uint, error)) *bridgeServiceStorageMock_GetDepositCountByRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeposits provides a mock function with given fields: ctx, destAddr, limit, offset, dbTx
func (_m *bridgeServiceStorageMock) GetDeposits(ctx context.Context, destAddr string, limit uint, offset uint, dbTx pgx.Tx) ([]*etherman.Deposit, error) {
	ret := _m.Called(ctx, destAddr, limit, offset, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetDeposits")
	}

	var r0 []*etherman.Deposit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint, uint, pgx.Tx) ([]*etherman.Deposit, error)); ok {
		return rf(ctx, destAddr, limit, offset, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint, uint, pgx.Tx) []*etherman.Deposit); ok {
		r0 = rf(ctx, destAddr, limit, offset, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*etherman.Deposit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint, uint, pgx.Tx) error); ok {
		r1 = rf(ctx, destAddr, limit, offset, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetDeposits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeposits'
type bridgeServiceStorageMock_GetDeposits_Call struct {
	*mock.Call
}

// GetDeposits is a helper method to define mock.On call
//   - ctx context.Context
//   - destAddr string
//   - limit uint
//   - offset uint
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetDeposits(ctx interface{}, destAddr interface{}, limit interface{}, offset interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetDeposits_Call {
	return &bridgeServiceStorageMock_GetDeposits_Call{Call: _e.mock.On("GetDeposits", ctx, destAddr, limit, offset, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetDeposits_Call) Run(run func(ctx context.Context, destAddr string, limit uint, offset uint, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetDeposits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint), args[3].(uint), args[4].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetDeposits_Call) Return(_a0 []*etherman.Deposit, _a1 error) *bridgeServiceStorageMock_GetDeposits_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetDeposits_Call) RunAndReturn(run func(context.Context, string, uint, uint, pgx.Tx) ([]*etherman.Deposit, error)) *bridgeServiceStorageMock_GetDeposits_Call {
	_c.Call.Return(run)
	return _c
}

// GetExitRootByGER provides a mock function with given fields: ctx, ger, dbTx
func (_m *bridgeServiceStorageMock) GetExitRootByGER(ctx context.Context, ger common.Hash, dbTx pgx.Tx) (*etherman.GlobalExitRoot, error) {
	ret := _m.Called(ctx, ger, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetExitRootByGER")
	}

	var r0 *etherman.GlobalExitRoot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) (*etherman.GlobalExitRoot, error)); ok {
		return rf(ctx, ger, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) *etherman.GlobalExitRoot); ok {
		r0 = rf(ctx, ger, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*etherman.GlobalExitRoot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, ger, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetExitRootByGER_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExitRootByGER'
type bridgeServiceStorageMock_GetExitRootByGER_Call struct {
	*mock.Call
}

// GetExitRootByGER is a helper method to define mock.On call
//   - ctx context.Context
//   - ger common.Hash
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetExitRootByGER(ctx interface{}, ger interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetExitRootByGER_Call {
	return &bridgeServiceStorageMock_GetExitRootByGER_Call{Call: _e.mock.On("GetExitRootByGER", ctx, ger, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetExitRootByGER_Call) Run(run func(ctx context.Context, ger common.Hash, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetExitRootByGER_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetExitRootByGER_Call) Return(_a0 *etherman.GlobalExitRoot, _a1 error) *bridgeServiceStorageMock_GetExitRootByGER_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetExitRootByGER_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) (*etherman.GlobalExitRoot, error)) *bridgeServiceStorageMock_GetExitRootByGER_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestExitRoot provides a mock function with given fields: ctx, isRollup, dbTx
func (_m *bridgeServiceStorageMock) GetLatestExitRoot(ctx context.Context, isRollup bool, dbTx pgx.Tx) (*etherman.GlobalExitRoot, error) {
	ret := _m.Called(ctx, isRollup, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestExitRoot")
	}

	var r0 *etherman.GlobalExitRoot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool, pgx.Tx) (*etherman.GlobalExitRoot, error)); ok {
		return rf(ctx, isRollup, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool, pgx.Tx) *etherman.GlobalExitRoot); ok {
		r0 = rf(ctx, isRollup, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*etherman.GlobalExitRoot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool, pgx.Tx) error); ok {
		r1 = rf(ctx, isRollup, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetLatestExitRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestExitRoot'
type bridgeServiceStorageMock_GetLatestExitRoot_Call struct {
	*mock.Call
}

// GetLatestExitRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - isRollup bool
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetLatestExitRoot(ctx interface{}, isRollup interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetLatestExitRoot_Call {
	return &bridgeServiceStorageMock_GetLatestExitRoot_Call{Call: _e.mock.On("GetLatestExitRoot", ctx, isRollup, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetLatestExitRoot_Call) Run(run func(ctx context.Context, isRollup bool, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetLatestExitRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetLatestExitRoot_Call) Return(_a0 *etherman.GlobalExitRoot, _a1 error) *bridgeServiceStorageMock_GetLatestExitRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetLatestExitRoot_Call) RunAndReturn(run func(context.Context, bool, pgx.Tx) (*etherman.GlobalExitRoot, error)) *bridgeServiceStorageMock_GetLatestExitRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRollupExitLeavesByRoot provides a mock function with given fields: ctx, root, dbTx
func (_m *bridgeServiceStorageMock) GetRollupExitLeavesByRoot(ctx context.Context, root common.Hash, dbTx pgx.Tx) ([]etherman.RollupExitLeaf, error) {
	ret := _m.Called(ctx, root, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetRollupExitLeavesByRoot")
	}

	var r0 []etherman.RollupExitLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) ([]etherman.RollupExitLeaf, error)); ok {
		return rf(ctx, root, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash, pgx.Tx) []etherman.RollupExitLeaf); ok {
		r0 = rf(ctx, root, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]etherman.RollupExitLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash, pgx.Tx) error); ok {
		r1 = rf(ctx, root, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRollupExitLeavesByRoot'
type bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call struct {
	*mock.Call
}

// GetRollupExitLeavesByRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - root common.Hash
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetRollupExitLeavesByRoot(ctx interface{}, root interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call {
	return &bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call{Call: _e.mock.On("GetRollupExitLeavesByRoot", ctx, root, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call) Run(run func(ctx context.Context, root common.Hash, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(common.Hash), args[2].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call) Return(_a0 []etherman.RollupExitLeaf, _a1 error) *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call) RunAndReturn(run func(context.Context, common.Hash, pgx.Tx) ([]etherman.RollupExitLeaf, error)) *bridgeServiceStorageMock_GetRollupExitLeavesByRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoot provides a mock function with given fields: ctx, depositCnt, network, dbTx
func (_m *bridgeServiceStorageMock) GetRoot(ctx context.Context, depositCnt uint, network uint, dbTx pgx.Tx) ([]byte, error) {
	ret := _m.Called(ctx, depositCnt, network, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetRoot")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, uint, pgx.Tx) ([]byte, error)); ok {
		return rf(ctx, depositCnt, network, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, uint, pgx.Tx) []byte); ok {
		r0 = rf(ctx, depositCnt, network, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, uint, pgx.Tx) error); ok {
		r1 = rf(ctx, depositCnt, network, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoot'
type bridgeServiceStorageMock_GetRoot_Call struct {
	*mock.Call
}

// GetRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - depositCnt uint
//   - network uint
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetRoot(ctx interface{}, depositCnt interface{}, network interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetRoot_Call {
	return &bridgeServiceStorageMock_GetRoot_Call{Call: _e.mock.On("GetRoot", ctx, depositCnt, network, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetRoot_Call) Run(run func(ctx context.Context, depositCnt uint, network uint, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(uint), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetRoot_Call) Return(_a0 []byte, _a1 error) *bridgeServiceStorageMock_GetRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetRoot_Call) RunAndReturn(run func(context.Context, uint, uint, pgx.Tx) ([]byte, error)) *bridgeServiceStorageMock_GetRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetTokenWrapped provides a mock function with given fields: ctx, originalNetwork, originalTokenAddress, dbTx
func (_m *bridgeServiceStorageMock) GetTokenWrapped(ctx context.Context, originalNetwork uint, originalTokenAddress common.Address, dbTx pgx.Tx) (*etherman.TokenWrapped, error) {
	ret := _m.Called(ctx, originalNetwork, originalTokenAddress, dbTx)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenWrapped")
	}

	var r0 *etherman.TokenWrapped
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, common.Address, pgx.Tx) (*etherman.TokenWrapped, error)); ok {
		return rf(ctx, originalNetwork, originalTokenAddress, dbTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, common.Address, pgx.Tx) *etherman.TokenWrapped); ok {
		r0 = rf(ctx, originalNetwork, originalTokenAddress, dbTx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*etherman.TokenWrapped)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, common.Address, pgx.Tx) error); ok {
		r1 = rf(ctx, originalNetwork, originalTokenAddress, dbTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// bridgeServiceStorageMock_GetTokenWrapped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTokenWrapped'
type bridgeServiceStorageMock_GetTokenWrapped_Call struct {
	*mock.Call
}

// GetTokenWrapped is a helper method to define mock.On call
//   - ctx context.Context
//   - originalNetwork uint
//   - originalTokenAddress common.Address
//   - dbTx pgx.Tx
func (_e *bridgeServiceStorageMock_Expecter) GetTokenWrapped(ctx interface{}, originalNetwork interface{}, originalTokenAddress interface{}, dbTx interface{}) *bridgeServiceStorageMock_GetTokenWrapped_Call {
	return &bridgeServiceStorageMock_GetTokenWrapped_Call{Call: _e.mock.On("GetTokenWrapped", ctx, originalNetwork, originalTokenAddress, dbTx)}
}

func (_c *bridgeServiceStorageMock_GetTokenWrapped_Call) Run(run func(ctx context.Context, originalNetwork uint, originalTokenAddress common.Address, dbTx pgx.Tx)) *bridgeServiceStorageMock_GetTokenWrapped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(common.Address), args[3].(pgx.Tx))
	})
	return _c
}

func (_c *bridgeServiceStorageMock_GetTokenWrapped_Call) Return(_a0 *etherman.TokenWrapped, _a1 error) *bridgeServiceStorageMock_GetTokenWrapped_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *bridgeServiceStorageMock_GetTokenWrapped_Call) RunAndReturn(run func(context.Context, uint, common.Address, pgx.Tx) (*etherman.TokenWrapped, error)) *bridgeServiceStorageMock_GetTokenWrapped_Call {
	_c.Call.Return(run)
	return _c
}

// newBridgeServiceStorageMock creates a new instance of bridgeServiceStorageMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newBridgeServiceStorageMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *bridgeServiceStorageMock {
	mock := &bridgeServiceStorageMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
